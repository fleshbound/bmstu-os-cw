\section{Аналитическая часть}

На основе цели работы формализуются требования к функционированию разрабатываемого сервера:
\begin{itemize}
	\item поддержка обработки запросов \texttt{GET}, \texttt{HEAD} --- осуществление отправки ответов со статусами 200, 403, 404;
	\item отправка ответа со статусом 405 в случае получения запроса, поддержка которого не предусмотрена;
	\item корректная передача файлов определенных выше форматов размером до 128 Мб;
	\item осуществление записи информации о событиях (логирования);
	\item использование паттерна пул потоков и системного вызова \texttt{select} при реализации.
\end{itemize}

\subsection{Модель клиент-сервер}

Клиент --- процесс, который нуждается в обслуживании \cite{kumar2019review}, \cite{oluwatosin2014client}.

Сервер --- процесс, который предоставляет ресурсы и обслуживание одному или нескольким клиентам \cite{kumar2019review}, \cite{oluwatosin2014client}.
Иногда в качестве сервера рассматривается отдельное множество процессов, запущенных на одной машине \cite{huhta2021multi}.

Клиент и сервер могут находиться как в одной сети, так и в разных; они обмениваются сообщениями по шаблону запрос-ответ.
Взаимодействие клиента и сервера происходит поэтапно следующим образом:
\begin{enumerate}
	\item клиент запрашивает соединение с сервером;
	\item сервер принимает или отклоняет запрос на соединение (в случае отказа дальнейшие шаги не выполняются);
	\item сервер устанавливает и поддерживает соединение с клиентом по определенному протоколу;
	\item клиент запрашивает ресурсы или службу у сервера (отправляет запрос);
	\item сервер получает и обрабатывает запрос, выполняя некоторые операции (обращение к базе данных, чтение файлов и так далее);
	\item сервер возвращает ответ.
\end{enumerate}

Существует два вида информации: статическая и динамическая \cite{аршакян2013оценка}.
Статической называется информация, которая относительно редко меняется с течением времени \cite{аршакян2013оценка}.
В рамках решаемой задачи под статической информацией подразумеваются файлы следующих форматов с указанными в скобках расширениями:
\begin{itemize}
	\item CSS (.css);
	\item JS (.js);
	\item HTML (.html);
	\item PNG, JPEG (.png, .jpeg, .jpg);
	\item SWF (.swf);
	\item GIF (.gif).
\end{itemize}


Сокет --- абстракция конечной точки коммуникационного взаимодействия~\cite{ryazan2023os}.
В языке Си он представляется файловым дескриптором.
Соединения между клиентом и сервером устанавливаются при помощи сокетов.

Для создания сокета используется системный вызов socket~\cite{kerrisk2010linux}, представленный на листинге \ref{lst:socket} и принимающий на вход следующие параметры:
\begin{itemize}
	\item \texttt{domain} --- семейство (AF\_UNIX, AF\_INET и др.);
	\item \texttt{type} --- тип (SOCK\_STREAM, SOCK\_RAW и др.);
	\item \texttt{protocol} --- протокол.
\end{itemize}

\begin{listing}[!h]
	\caption{Системный вызов socket}
	\label{lst:socket}
	\begin{minted}[frame=single,fontsize = \footnotesize, linenos, xleftmargin = 1.5em]{c}
int socket(int domain, int type, int protocol);
	\end{minted}
\end{listing}

\subsection{Пул потоков}

Пул потоков (англ. thread pool) --- архитектурный паттерн, предназначенный для многопоточной обработки информации и основанный на хранении заранее созданных и используемых потоков \cite{опарин2022многопоточность}.

Создание и настройка потока являются процессами, задерживающими работу приложения, поэтому для снижения накладных расходов был разработан пул потоков \cite{опарин2022многопоточность}.

В данной технологии предлагается создать набор (пул) потоков определенной величины и сохранять его состояние на протяжении всей работы приложения.
Для обработки каждого приходящего запроса используется очередной свободный поток из ранее созданного пула.
Он помечается как занятый, а после обработки запроса --- отмечается свободным (возвращается в пул).

Основные проблемы, возникающие при применении технологии \cite{опарин2022многопоточность}:
\begin{enumerate}
	\item <<простаивание>> потоков;
	\item обработка одним потоком нескольких запросов;
	\item проблема определения числа потоков.
\end{enumerate}

Для решения первых двух проблем необходимо использовать средства взаимоисключения (например, мьютексы) \cite{ryazan2023os} и отдельный сокет на каждый поток.

Третья проблема решается указанием числа потоков при запуске сервера.

Схема использования пула потоков представлена на рисунке \ref{img:thread_pool}.

\begin{figure}[!htb]\centering
	\includegraphics[width=0.7\textwidth]{../img/thread_pool.pdf}
	\caption{Схема использования пула потоков}
	\label{img:thread_pool}
\end{figure}

\subsection{Асинхронный блокирующий ввод-вывод}

Мультиплексирование (асинхронный блокирующий ввод-вывод) --- процесс совмещения нескольких сообщений, передающихся одновременно, в одной логической или физической среде \cite{ryazan2023os}.
Оно основывается на одновременном (асинхронном) опросе и сборе информации о готовности источников.
На момент опроса процесс блокируется в ожидании соединения.
После установления соединения с активным источником начинается обработка данных.
Следующая блокировка происходит в ожидании результата чтения, а затем выполняется передача данных из пространства ядра в пространство пользователя.

Модель асинхронного блокирующего ввода-вывода с использованием системного вызова select представлена на рисунке \ref{img:multiplex}.

\begin{figure}[!htb]\centering
	\includegraphics[width=0.9\textwidth]{../img/multiplex.pdf}
	\caption{Модель асинхронного блокирующего ввода-вывода}
	\label{img:multiplex}
\end{figure}

Системный вызов select, представленный на листинге \ref{lst:select}, используется для отслеживания нескольких активных файловых дескрипторов.
Параметры select:
\begin{itemize}
	\item nfds --- максимальное число файловых дескрипторов в перечисленных ниже массивах, увеличенное на единицу;
	\item readfds --- массив активных файловых дескрипторов (для чтения);
	\item writefds --- массив активных файловых дескрипторов (для записи);
	\item exceptfds --- массив активных файловых дескрипторов (для иных ситуаций);
	\item timeout --- структура timeval, описывающая временной интервал блокировки.
\end{itemize}

\begin{listing}[!h]
	\caption{Системный вызов select}
	\label{lst:select}
	\begin{minted}[frame=single,fontsize = \footnotesize, linenos, xleftmargin = 1.5em]{c}
int select(int nfds, fd_set *_Nullable restrict readfds,
	   fd_set *_Nullable restrict writefds,
	   fd_set *_Nullable restrict exceptfds,
	   struct timeval *_Nullable restrict timeout);
	\end{minted}
\end{listing}

\subsection{Протоколы}

Протокол --- соглашение логического уровня между интерфейсами \cite{tikhomirova2024networks}.

Представителями протоколов прикладного уровня являются HTTP, FTP, SMTP \cite{lombardi2021internet}.

FTP --- протокол передачи файлов по сети, предназначенный для обмена данными между хостами через промежуточные системы \cite{forouzan2002tcp}.
Данный протокол основан на модели клиент-сервер, гарантирует доставку данных.
Соединения для управления и передачи между клиентом и сервером в нем разделены.
Команды \texttt{GET}, \texttt{HEAD} данный протокол не поддерживает.

SMTP --- протокол, предназначенный для передачи электронной почты \cite{johnson2000internet}.
Архитектура протокола соответствует модели <<клиент-сервер>>.
Принцип работы основан на обмене последовательностями, которые описываются с помощью \texttt{MAIL FROM}, \texttt{RCPT TO}, \texttt{DATA}.

HTTP --- протокол для распределённых, объединённых, гипермедийных информационных систем \cite{rfc9112}.
Основой протокола является технология <<клиент-сервер>>.
Главный объект манипуляции --- ресурс, на который указывает URI в запросе клиента.
В рамках HTTP протокола TCP-сессия устанавливается на каждый запрос.

Таким образом, для достижения цели следует реализовать сервер, поддерживающий соединения по протоколу HTTP.

HTTP сообщение состоит из трех частей:
\begin{enumerate}
	\item строки запроса (стартовая);
	\item заголовков, описывающие параметры передачи и так далее;
	\item тела сообщения.
\end{enumerate}
Одним из заголовков является метод запроса, примерами которого являются \texttt{GET}, \texttt{HEAD}.

\texttt{GET} используется в запросах определенного ресурса; тело запроса в случае этого метода будет пустым, а в теле ответа будет содержаться запрошенная информация (содержимое интересующего файла).

\texttt{HEAD} аналогичен \texttt{GET}, служит для проверки наличия ресурса или извлечения метаданных, поскольку тело ответа на данный метод отсутствует.

\subsection{Существующие решения}

Веб-сервер --- сервер, осуществляющий взаимодействие с клиентами по протоколу HTTP.

Согласно информации, представленной в \cite{netcraft2024stat}, наиболее распространенными за последние 4 года веб-серверами являются NGINX, Cloudflare, Apache.

NGINX \cite{nginx} --- веб-сервер, прокси-сервер с открытым исходным кодом, поддерживающий Unix-подобные операционные системы и частично операционные системы семейства Windows.
Он позиционируется как простой, быстрый и надёжный сервер, использование которого является целесообразным для раздачи статической информации.
Основа работы данного сервера --- обработка одним потоком нескольких запросов.
По данным \cite{netcraft2024stat} к ноябрю 2024 года NGINX используется для поддержки 220 миллионов сайтов, что составляет 19\% от общего количества.

Apache \cite{apacheserver} --- веб-сервер с открытым исходным кодом, поддерживающий большое количество операционных систем, в числе которых Unix-подобные ОС, ОС семейства Windows, OpenVMS.
В ходе работы сервера каждый поток обрабатывает только один запрос.
По данным \cite{netcraft2024stat} к ноябрю 2024 года Apache используется для поддержки 199 миллионов сайтов (17\%).

Cloudflare \cite{cloudflare} --- американская компания, предоставляющая услуги по раздаче статической информации, защите от атак, предоставлению серверов DNS и проксированию сайтов.
По данным \cite{netcraft2024stat} к ноябрю 2024 года услугами Cloudflare пользуются 134 миллионов сайтов (12\%).

Таким образом, самым распространенным решением является NGINX.
Сравнение разрабатываемого сервера по результатам тестирования будет проводиться с ним.

\subsection*{Вывод}

Был проведен анализ предметной области сервера для отдачи статической информации.
Для реализации будут использоваться соединения на основе протокола HTTP, пул потоков и системный вызов select (асинхронный блокирующий ввод-вывод).
Результаты тестирования сервера будут сравниваться с результатами тестирования NGINX.